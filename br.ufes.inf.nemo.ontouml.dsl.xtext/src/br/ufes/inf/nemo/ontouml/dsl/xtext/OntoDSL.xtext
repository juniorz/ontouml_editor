// automatically generated by Xtext
grammar br.ufes.inf.nemo.ontouml.dsl.xtext.OntoDSL
	with org.eclipse.xtext.common.Terminals hidden(NL, RWS, WS, SL_COMMENT, ML_COMMENT) //Para adicionar um em hidden tem que redefinir Todos 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://nemo.inf.ufes.br/ontouml/dsl" as dsl
import "http://nemo.inf.ufes.br/ontouml/refontouml"

/*
 * NOTAS
 *
 * Para rodar esse generator:
 * Right-click .mwe2 file, Run As, Run Configurations, Arguments, VM Arguments
 * -Xms756m -Xmx1g
 */

/*
 DECISÕES
 
 - LiteralUnlimitedNatural é apenas o * (unlimited). Qualquer INT é IntegerLiteral
 - OpaqueExpression o que vai dentro do body não tem como possuir comentários, nem manter o registro de NLs. Cada membro de body é uma linha do corpo.
   Isso é uma restrição do xText que pra facilitar as coisas, ignora os tokens de comentários, NL e espaços
 */


/*
 * Seria interessante trabalhar nas Constraints
 *
 */
// #Model
Model returns dsl::DslModel:
	{dsl::DslModel}
	'model' name=ID
	('viewpoint' viewpoint=STRING)?
	'{'
		//('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		//('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		//('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		(packagedElement+=PackageableElement)*
	'}'
;


PackageableElement returns PackageableElement:
	Type | Instance | Class | Association | GeneralizationSet

//	Association_Impl | GeneralizationSet
//	Class_Impl | Model | Enumeration | EnumerationLiteral | PrimitiveType
//	| StringExpression | Expression_Impl | OpaqueExpression | LiteralInteger | LiteralString | LiteralBoolean | LiteralNull | InstanceValue | LiteralUnlimitedNatural //(ACHO que não precisa, só se forem named)

//	| Dependency | Constraintx |
//	Package_Impl | GeneralizationSet | InstanceSpecification_Impl
;

Class:
	Kind | 
	Quantity |
	Collective |
	SubKind |
	Category |
	Phase |
	Role |
	Mixin |
	RoleMixin |
	Mode |
	Relator
;

Association:
	Characterization |
	Mediation |
	Derivation |

//	memberOf |
//	componentOf |
//	subQuantityOf |
//	subCollectionOf |

	FormalAssociation |
	MaterialAssociation 
;


/*
 * ONTOUML
 */

// #Kind (SubstanceSortal)
Kind returns Kind:
	(isActive?='active'? & isAbstract?='abstract'?)
	'kind' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}'
;


// #Quantity (SubstanceSortal)
Quantity returns Quantity:
	(isActive?='active'? & isAbstract?='abstract'?)
	'quantity' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';


// #Collective (SubstanceSortal)
Collective returns Collective:
	(isActive?='active'? & isExtensional?='extensional'? & isAbstract?='abstract'?)
	'collective' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';


// #SubKind (RigidSortal)
SubKind returns SubKind:
	(isActive?='active'? & isAbstract?='abstract'?)
	'subKind' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';

// #Category (RigidMixin)
Category returns Category:
	(isActive?='active'? & isAbstract?='abstract') // abstract: required (poderia colocar abstract+='{' ...)
	'category' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';

// #Phase (AntiRigidSortal)
Phase returns Phase:
	(isActive?='active'? & isAbstract?='abstract'?)
	'phase'	name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';

// #Role (AntiRigidSortal)
Role returns Role:
	(isActive?='active'? & isAbstract?='abstract'?)
	'role' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';

// #Mixin (SemiRigidMixin)
Mixin returns Mixin:
	(isActive?='active'? & isAbstract?='abstract') // abstract: required
	'mixin' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';

// #RoleMixin (AntiRigidMixin)
RoleMixin returns RoleMixin:
	(isActive?='active'? & isAbstract?='abstract'?)
	'roleMixin' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';

// #Mode (Moment)
Mode returns Mode:
	(isActive?='active'? & isAbstract?='abstract'?)
	'mode' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}';


// #Relator (Moment)
Relator: OriginalRelator 
	| SimplifiedRelator
;

OriginalRelator returns Relator:
	(isActive?='active'? & isAbstract?='abstract'?)
	'relator' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		(ownedAttribute+=ClassProperty ';')*
    '}'
;


SimplifiedRelator returns dsl::DslRelator:
	(isActive?='active'? & isAbstract?='abstract'?)
	'simpleRelator' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
    'mediates'
    mediations+=SimpleMediation ('and' mediations+=SimpleMediation)+
	'{'
        (ownedAttribute+=ClassProperty ';')*
    '}'
;


SimpleMediation returns dsl::DslMediation:
    {dsl::DslMediation}
//    'mediates'
    ('<' name=ID '>')?
    mediated=AnonymousPropertyDefinition
;

// #Characterization (DependencyRelationship)
Characterization returns Characterization:
//	( isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? )
	'characterization' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		'mode:' ( ownedEnd+=InlinePropertyDefinition ';' )
		'characterized:' ( ownedEnd+=InlinePropertyDefinition ';' )
    '}'
;

// #Mediation (DependencyRelationship)
Mediation returns Mediation:
//	( isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? )
	'mediation' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
	(
		('relator:' ownedEnd+=InlinePropertyDefinition ';' )		// relator
		('mediated:' ownedEnd+=InlinePropertyDefinition ';' )		// mediated
		                      										// TODO: Tem que ser [>1, ?]
	)
    '}'
;

// #Derivation (DependencyRelationship)
Derivation returns Derivation:
//	( isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? )
	'derivation' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		'material:' ( ownedEnd+=InlinePropertyDefinition ';' )
		'relator:' ( ownedEnd+=InlinePropertyDefinition ';' )
    '}'
;

// #memberOf (Meronymic)
memberOf returns memberOf:
	{memberOf}
	(
	  isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? &
	  isEssential?='essential'? & isImmutablePart?='imutablePart'? & isImmutableWhole?='imutableWhole'? & isInseparable?='inseparable'? & isShareable?='shareable'?
	)
	'memberOf' name=ID
	'{'
//        (ownedEnd+=ClassProperty ';')*
    '}';

// #componentOf (Meronymic)
componentOf returns componentOf:
	{componentOf}
	(
	  isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? &
	  isEssential?='essential'? & isImmutablePart?='imutablePart'? & isImmutableWhole?='imutableWhole'? & isInseparable?='inseparable'? & isShareable?='shareable'?
	)
	'componentOf' name=ID
	'{'
//        (ownedEnd+=ClassProperty ';')*
    '}';

// #subQuantityOf (Meronymic)
subQuantityOf returns subQuantityOf:
	{subQuantityOf}
	//( isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? )
	//( isEssential?='essential'? & isImmutablePart?='imutable-part'? & isImmutableWhole?='imutable-whole'? & isInseparable?='inseparable'? & isShareable?='shareable'? )
	'subQuantityOf' name=ID
	'{'
//        (ownedEnd+=ClassProperty ';')*
    '}';

// #subCollectionOf (Meronymic)
subCollectionOf returns subCollectionOf:
	{subCollectionOf}
	//( isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? )
	//( isEssential?='essential'? & isImmutablePart?='imutable-part'? & isImmutableWhole?='imutable-whole'? & isInseparable?='inseparable'? & isShareable?='shareable'? )
	'subCollectionOf' name=ID
	'{'
//        (ownedEnd+=ClassProperty ';')*
    '}';


/*
 *
 * public property casadoCom (Pessoa) throught contratoDeCasamento //MaterialAssociation
 * OCL: Precisa de um Derivation cujo memberEnd[1] = MaterialAssociation
 */
MaterialAssociation returns MaterialAssociation:
	{MaterialAssociation}
	( isDerived?='derived' & isAbstract?='abstract'? & isLeaf?='leaf'? ) // derived: required
	'materialAssociation' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
//		( ownedEnd+=InlinePropertyDefinition ';' )+
    '}'
;


//public property maisVelhoQue (Pessoa) //FormalAssociation entre Pessoa e Pessoa
FormalAssociation returns FormalAssociation:
	{FormalAssociation}
	( isAbstract?='abstract'? & isDerived?='derived'? & isLeaf?='leaf'? )
	'formalAssociation' name=ID?
	'{'
//		( ownedEnd+=InlinePropertyDefinition ';' )+
    '}'
	;




NonExpressionValue returns ValueSpecification:
	LiteralInteger | LiteralString | LiteralNull | LiteralBoolean | InstanceValue | OpaqueExpression
;

ValueSpecification returns ValueSpecification:
	//StringExpression | //O que é iso???
	NonExpressionValue |  ExpressionValue
;

Type : DataType | PrimitiveType;

DataType returns DataType:
	'datatype'
	name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	('{'
		(ownedAttribute+=ClassProperty ';')+
    '}')?
;

//???: Mesma coisa que DataType?
PrimitiveType returns PrimitiveType:
	'type'
	name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
;

Dependency returns Dependency:
	{Dependency}
	'Dependency'
	(name=ID)?
	'{'
		client+=[NamedElement] (',' client+=[NamedElement])*
		'depends on' '(' supplier+=[NamedElement] ( ',' supplier+=[NamedElement])* ')'  
    '}'
;



ElementImport returns ElementImport:
	'import'
	importedElement=[PackageableElement|STRING]
	('as' alias=ID)?
	';'
;

PackageImport returns PackageImport:
	'import' importedPackage=[Package|STRING]
	';'
;

Constraintx returns Constraintx:
	'constraint'
	('(' constrainedElement+=[Element] ( "," constrainedElement+=[Element])* ')' )?
	'{'
		specification=ValueSpecification
    '}'
;

PackageMerge returns PackageMerge:
	{PackageMerge}
	//('PackageMerge')?
	mergedPackage=[Package|STRING]
;

Package_Impl returns Package:
	{Package}
	'package'
	name=ID
	'{'
		('merge' ':' packageMerge+=PackageMerge ( ',' packageMerge+=PackageMerge)* )?
		(packagedElement+=PackageableElement)*
	'}'
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
;

/*****************************************************************************
 * Duvida:
 * Generalization::generalizationSet é uma collection, por que?
 *****************************************************************************/
InlineGeneralization returns Generalization:
	isSubstitutable?='substitutable'?
	general=[Classifier]
	('(' generalizationSet+=[GeneralizationSet] (',' generalizationSet+=[GeneralizationSet])* ')' )?
	//('(' generalizationSet+=[GeneralizationSet] ')' )?
;


/*
 * Problema: Não tem name, como referenciar?
 */
Generalization returns Generalization:
	//isSubstitutable?='substitutable'? //Default tá sendo TRUE?
	'generalization'
	'of' general=[Classifier]
	'as' owner=[Classifier]
	';'
;

/*****************************************************************************
 * Problemas:
 * GeneralizationSet::generalization é opposite, mas não está sendo definida automaticamente
 * Motivo: http://www.eclipse.org/forums/index.php/t/245235/
 * Solução, mudar essas opposite que são assim, para transient="true" e resolveProxies="false"
 *****************************************************************************/
GeneralizationSet returns GeneralizationSet:
	( isCovering?='complete'? & isDisjoint?='disjoint'? )
	'generalizationSet' name=ID
	'{'
    '}'
;


//Um operador (+, -, >, <)
//100 + 2
//100 op[shif] 2
ExpressionSymbol returns ecore::EString:
	DefaultOperator | ('op' '[' ID ']' )
;

DefaultOperator:
	'+' | '-' | '*' | '/'
;

/*
 *
 * (100 + 100 - 200)
 * media {10, 20, 30}
 * not 100
 */
 //TODO: resolver o left-recursion
ExpressionValue returns Expression:
	{Expression}
	'('
		(
		 //Se eu tiro o parenteses dá left-recursion 
		 (operand+=ValueSpecification symbol=ExpressionSymbol operand+=ValueSpecification) |
		 (symbol=ExpressionSymbol operand+=ValueSpecification) |
		 (symbol=ExpressionSymbol '{' operand+=ValueSpecification (',' operand+=ValueSpecification)+ '}')
		)
    ')'
;

/*
private OpaqueExpression opaqExp1 (Person) : "Python", "Ruby"
		begin
			# Reinaldo de souza junior
			# Reinaldo2
		end
*/
OpaqueExpression returns OpaqueExpression:	//OK
	{OpaqueExpression}
	'OpaqueExpression'
	(name=ID)?
	('(' type=[Type] ')')?
	':' language+=STRING ( ','  language+=STRING)*
	//'begin' body+=OPAQUE_TEXT 'end'
	'begin' ('#' body+=LINE)* 'end'
;


LINE returns ecore::EString: (ID|INT|RWS|ANY_OTHER)+; 
//OPAQUE_TEXT returns ecore::EString:
//	LINE (NL LINE)*
//;




//+ -> concatena
//% -> interpola
//StringExpressionSymbol returns ecore::EString:
//	'+' | '%'
//	;

//Isso seria uma expressão Terminal?
//Se eu substituir o primeiro operand+=ValueSpecification por operand+=TerminalStringExpression funcionaria sem left-recursion
//TerminalStringExpression returns StringExpression:
//	operand+=LiteralString
//	;

//WTF is a StringExpression?
//Devo usar subExpresion, symbol, subExpression
//ou devo usar operand, symbol, operand (de Expression)
//Aqui eu definiria quais as operações poderiam ser realizadas com STRINGs? 
/*
StringExpression returns StringExpression:
	{StringExpression}
	//"Reinaldo" + " Junior"
	('(' //Se eu tirar o parenteses eu vou ter uma chamada recursiva à esquerda, o que não pode no ANTLR
		operand+=ValueSpecification
		symbol='+'
		operand+=ValueSpecification
	')')
	//("Reinaldo %1 conheçe %2? %3" % "Junior", instancia_maria.nome, true)
	| ('('
		operand+=ValueSpecification
		symbol='%'
		operand+=ValueSpecification (',' operand+=ValueSpecification )?
	')')
// //Seria como uma operação, apenas
//	|
//	('('
//		operand+=StringExpression
//		symbol=StringExpressionSymbol
//		operand+=ValueSpecification
//	')')
    ;
*/

AnonymousPropertyDefinition returns Property:
	{Property}
	type=[Type]
	( '[' lowerValue=LiteralInteger ',' upperValue=LiteralUnlimitedNatural ']')?
;

InlinePropertyDefinition returns Property:
	{Property}
	name=ID?
	(
	  '('
	   ( isStatic?='static'? & isOrdered?='ordered'? & isUnique?='unique'? & isReadOnly?='read-only'? & isDerivedUnion?='derived-union'? )
	   ')'
	)?
	type=[Type]
	( '[' lowerValue=LiteralInteger ',' upperValue=LiteralUnlimitedNatural ']')?
	('{'
		('defaults to' defaultValue=ValueSpecification)?
		('aggregation' aggregation=AggregationKind)?
		('subset of' '(' subsettedProperty+=[Property] ( "," subsettedProperty+=[Property])* ')' )?
		('redefines' '(' redefinedProperty+=[Property] ( "," redefinedProperty+=[Property])* ')' )?
    '}')?
;

/*
 Sintaxe para criar properties em Classes
 - public Person father[1, 2] (unique)
 - public father[1,2] (Person) <unique>
 - public (unique) father[1,2] : Person
*/
ClassProperty returns Property:
	{Property}
	(
	  '('
	   ( isStatic?='static'? & isOrdered?='ordered'? & isUnique?='unique'? & isReadOnly?='read-only'? & isDerivedUnion?='derived-union'? )
	   ')'
	)?
	name=ID
	( '[' lowerValue=LiteralInteger ',' upperValue=LiteralUnlimitedNatural ']')?
	':' type=[Type]
	('{'
		('defaults to' defaultValue=ValueSpecification)?
		('aggregation' aggregation=AggregationKind)?
		('subset of' '(' subsettedProperty+=[Property] ( "," subsettedProperty+=[Property])* ')' )?
		('redefines' '(' redefinedProperty+=[Property] ( "," redefinedProperty+=[Property])* ')' )?
    '}')?
;


/*
//Igual a propriedade
//relation maisVelhoQue(Pessoa) //FormalAssociation entre Pessoa e Pessoa
//relation casadoCom(Pessoa) throught contratoDeCasamento //MaterialAssociation

Relation returns Property:
	(visibility=VisibilityKind)?
	'relation'
	('('
	 (isStatic?='static' & isOrdered?='ordered' & isUnique?='unique' & isReadOnly?='read-only' & isDerivedUnion?='derived-union')
	 ')'
	)?
	name=ID
//	('[' upperValue=ValueSpecification ',' lowerValue=ValueSpecification ']')?
	':' type=[Type]
//	('default=' defaultValue=ValueSpecification)?

//?
//	'->' association=[Association|ID]
//	owningAssociation+=[Association]
//	owningAssociation=[Association] //oposite -> ownedEnd
	association=[Association] //oposite -> memberEnd

	('{'
		('aggregation' aggregation=AggregationKind)?
		('subset of' '(' subsettedProperty+=[Property|STRING] ( "," subsettedProperty+=[Property|STRING])* ')' )?
		('redefines' '(' redefinedProperty+=[Property|STRING] ( "," redefinedProperty+=[Property|STRING])* ')' )?

//		
//Opposite em Dependency, não precisa definir
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
    '}')?
;
*/


//CharacterizationMode returns Property:
//	{Property}
//	name=ID?
//	(
//	  '('
//	   ( visibility=VisibilityKind? & isStatic?='static'? & isOrdered?='ordered'? & isUnique?='unique'? & isReadOnly?='read-only'? & isDerivedUnion?='derived-union'? )
//	   ')'
//	)?
//	type=[Mode]
//	( '[' lowerValue=LiteralInteger ',' upperValue=LiteralUnlimitedNatural ']')?
//	('{'
//		('defaults to' defaultValue=ValueSpecification)?
//		('aggregation' aggregation=AggregationKind)?
//		('subset of' '(' subsettedProperty+=[Property] ( "," subsettedProperty+=[Property])* ')' )?
//		('redefines' '(' redefinedProperty+=[Property] ( "," redefinedProperty+=[Property])* ')' )?
//    '}')?
//;

//CharacterizationCharacterized returns Property:
//	{Property}
//	name=ID?
//	(
//	  '('
//	   ( visibility=VisibilityKind? & isStatic?='static'? & isOrdered?='ordered'? & isUnique?='unique'? & isReadOnly?='read-only'? & isDerivedUnion?='derived-union'? )
//	   ')'
//	)?
//	type=[Type]
//	// CharacterizationConstraint2
//	//( '[' lowerValue=LiteralInteger ',' upperValue=LiteralUnlimitedNatural ']')?
//	('{'
//		('defaults to' defaultValue=ValueSpecification)?
//		('aggregation' aggregation=AggregationKind)?
//		('subset of' '(' subsettedProperty+=[Property] ( "," subsettedProperty+=[Property])* ')' )?
//		('redefines' '(' redefinedProperty+=[Property] ( "," redefinedProperty+=[Property])* ')' )?
//    '}')?
//;


	
/* 
Association_Impl returns Association:
	'Association'
	'{'
		('name' name=ID)?
		('visibility' visibility=VisibilityKind)?
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property|EString] ( "," memberEnd+=[Property|EString])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property|EString] ( "," navigableOwnedEnd+=[Property|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('ownedEnd' '{' ownedEnd+=Property ( "," ownedEnd+=Property)* '}' )?
    '}';


Class_Impl returns Class:
	'Class'
	'{'
		('name' name=ID)?
		('visibility' visibility=VisibilityKind)?

		
		'isActive' isActive=Boolean
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
    '}';

*/


Enumeration returns Enumeration:
	'enum'
	name=ID
	'{'
		ownedLiteral+=EnumerationLiteral ( "," ownedLiteral+=EnumerationLiteral)*
//		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?

//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
	'}'
;

EnumerationLiteral returns EnumerationLiteral:
	{EnumerationLiteral}
//	'EnumerationLiteral'
//	'{'
		name=ID
		'='
		specification=ValueSpecification
//		('visibility' visibility=VisibilityKind)?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('classifier' '(' classifier+=[Classifier|EString] ( "," classifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?	
//		('slot' '{' slot+=Slot ( "," slot+=Slot)* '}' )?
//    '}'
;

/*
 * Especifica uma instância
 */
Instance returns InstanceSpecification:
	{InstanceSpecification}
	'instance'
	name=ID
	(':' classifier+=[Classifier] ( "," classifier+=[Classifier])* )?
	('specification' specification=ValueSpecification)?
	'{' (slot+=Slot ( "," slot+=Slot)*)? '}'
;

Slot returns Slot:
	definingFeature=[StructuralFeature|ID]
	'=>'
	(value+=ValueSpecification | '[' value+=ValueSpecification ( "," value+=ValueSpecification)* ']' )
;

//InstanceValue
/*
 * Refere-se a uma instânca como um valor
 *
 * private instance reinaldinho (Person)
*/
InstanceValue returns InstanceValue: //OK
	instance=[InstanceSpecification]
	('(' type=[Type] ')')?
;


//Um UnlimitedNatural pode ser reduzido a um INT assim como um LiteralInteger
//Por isso tá dando ambiguidade na gramática??? Mas ainda assim está funcionando.
LiteralInteger returns LiteralInteger:
	{LiteralInteger}
	value=INT
;

LiteralString returns LiteralString:
	{LiteralString}
	value=STRING
;

LiteralBoolean returns LiteralBoolean:
	{LiteralBoolean}
	value=Boolean
;

Boolean returns ecore::EBoolean:
	'true' | 'false'
;

//Acho que não precisa
//EBoolean returns ecore::EBoolean:
//	'true' | 'false';

LiteralUnlimitedNatural:
	value=UnlimitedNaturalValue | value=INT
;

UnlimitedNaturalValue returns /*ecore::EInt*/ ecore::EIntegerObject:
	'*' // | INT
;

//Tentar um ValueConverter??
LiteralNull returns LiteralNull:
	{LiteralNull}
	'NULL'
;




//Terminals
//RWS -> Real White Space (fiz isso porque os terminais padrão do xText não diferenciam WhiteSpace de New-Line
terminal RWS: (' '|'\t')+;
terminal NL: ('\r'|'\n')+;
terminal WS: (RWS|NL)+;
//terminal WORD: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+;


//Lista de Enumerações
enum AggregationKind returns AggregationKind:
	none = 'none' | shared = 'shared' | composite = 'composite';

/*
EClassifier returns ecore::EClassifier:
	EClass | EDataType_Impl | EEnum;

EStructuralFeature returns ecore::EStructuralFeature:
	EAttribute | EReference;

EAnnotation returns ecore::EAnnotation:
	{ecore::EAnnotation}
	'EAnnotation'
	'{'
		('source' source=EString)?
		('references' '(' references+=[ecore::EObject|EString] ( "," references+=[ecore::EObject|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('details' '{' details+=EStringToStringMapEntry ( "," details+=EStringToStringMapEntry)* '}' )?
		('contents' '{' contents+=EObject ( "," contents+=EObject)* '}' )?
    '}';

//SL_COMMENT | ML_COMMENT
Comment returns Comment:
	{Comment}
	'Comment'
	'{'
		('body' body=STRING)?
		('annotatedElement' '(' annotatedElement+=[Element|EString] ( "," annotatedElement+=[Element|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
    '}';
    
EString returns ecore::EString:
	STRING | ID;

EStringToStringMapEntry returns ecore::EStringToStringMapEntry:
	{ecore::EStringToStringMapEntry}
	'EStringToStringMapEntry'
	'{'
		('key' key=EString)?
		('value' value=EString)?
    '}';

EObject_Impl returns ecore::EObject:
	{ecore::EObject}
	'EObject'
;

EAttribute returns ecore::EAttribute:
	{ecore::EAttribute}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(iD?='iD')?
	'EAttribute'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('changeable' changeable=EBoolean)?
		('defaultValueLiteral' defaultValueLiteral=EString)?
		('eType' eType=[ecore::EClassifier|EString])?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
    '}';

EClass returns ecore::EClass:
	{ecore::EClass}
	(abstract?='abstract')?
	(interface?='interface')?
	'EClass'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('eSuperTypes' '(' eSuperTypes+=[ecore::EClass|EString] ( "," eSuperTypes+=[ecore::EClass|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eOperations' '{' eOperations+=EOperation ( "," eOperations+=EOperation)* '}' )?
		('eStructuralFeatures' '{' eStructuralFeatures+=EStructuralFeature ( "," eStructuralFeatures+=EStructuralFeature)* '}' )?
		('eGenericSuperTypes' '{' eGenericSuperTypes+=EGenericType ( "," eGenericSuperTypes+=EGenericType)* '}' )?
    '}';


EDataType_Impl returns ecore::EDataType:
	{ecore::EDataType}
	'EDataType'
	name=ID
	'{'
//		('instanceClassName' instanceClassName=EString)?
//		('instanceTypeName' instanceTypeName=EString)?
//		('serializable' serializable=EBoolean)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
    '}';


EEnum returns ecore::EEnum:
	{ecore::EEnum}
	'EEnum'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('serializable' serializable=EBoolean)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eLiterals' '{' eLiterals+=EEnumLiteral ( "," eLiterals+=EEnumLiteral)* '}' )?
    '}';

EEnumLiteral returns ecore::EEnumLiteral:
	{ecore::EEnumLiteral}
	'EEnumLiteral'
	name=EString
	'{'
		('value' value=EInt)?
		('literal' literal=EString)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
    '}';

EFactory returns ecore::EFactory:
	{ecore::EFactory}
	'EFactory'
	'{'
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
    '}';

EOperation returns ecore::EOperation:
	{ecore::EOperation}
	'EOperation'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eExceptions' '(' eExceptions+=[ecore::EClassifier|EString] ( "," eExceptions+=[ecore::EClassifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eParameters' '{' eParameters+=EParameter ( "," eParameters+=EParameter)* '}' )?
		('eGenericExceptions' '{' eGenericExceptions+=EGenericType ( "," eGenericExceptions+=EGenericType)* '}' )?
    '}';

EPackage returns ecore::EPackage:
	{ecore::EPackage}
	'EPackage'
	name=EString
	'{'
		('nsURI' nsURI=EString)?
		('nsPrefix' nsPrefix=EString)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eClassifiers' '{' eClassifiers+=EClassifier ( "," eClassifiers+=EClassifier)* '}' )?
		('eSubpackages' '{' eSubpackages+=EPackage ( "," eSubpackages+=EPackage)* '}' )?
    '}';

EParameter returns ecore::EParameter:
	{ecore::EParameter}
	'EParameter'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('eType' eType=[ecore::EClassifier|EString])?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
    '}';

EReference returns ecore::EReference:
	{ecore::EReference}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(containment?='containment')?
	'EReference'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('changeable' changeable=EBoolean)?
		('defaultValueLiteral' defaultValueLiteral=EString)?
		('resolveProxies' resolveProxies=EBoolean)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eOpposite' eOpposite=[ecore::EReference|EString])?
		('eKeys' '(' eKeys+=[ecore::EAttribute|EString] ( "," eKeys+=[ecore::EAttribute|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
    '}';

EGenericType returns ecore::EGenericType:
	{ecore::EGenericType}
	'EGenericType'
	'{'
		('eTypeParameter' eTypeParameter=[ecore::ETypeParameter|EString])?
		('eClassifier' eClassifier=[ecore::EClassifier|EString])?
		('eUpperBound' eUpperBound=EGenericType)?
		('eTypeArguments' '{' eTypeArguments+=EGenericType ( "," eTypeArguments+=EGenericType)* '}' )?
		('eLowerBound' eLowerBound=EGenericType)?
    '}';

ETypeParameter returns ecore::ETypeParameter:
	{ecore::ETypeParameter}
	'ETypeParameter'
	name=EString
	'{'
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eBounds' '{' eBounds+=EGenericType ( "," eBounds+=EGenericType)* '}' )?
    '}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EInt returns ecore::EInt:
	'-'? INT;
*/