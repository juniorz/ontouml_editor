// automatically generated by Xtext
//Talvez valha a pena criar meus próprios terminais
grammar br.ufes.inf.nemo.ontouml.dsl.DslOntoUML with org.eclipse.xtext.common.Terminals hidden(NL, RWS, WS, SL_COMMENT, ML_COMMENT) //Para adicionar um em hidden tem que redefinir Todos

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "http://nemo.inf.ufes.br/ontouml/refontouml"
import  "RefOntoUML"

/*
 DECISÕES
 
 - LiteralUnlimitedNatural é apenas o * (unlimited). Qualquer INT é IntegerLiteral
 - OpaqueExpression o que vai dentro do body não tem como possuir comentários, nem manter o registro de NLs. Cada membro de body é uma linha do corpo.
   Isso é uma restrição do xText que pra facilitar as coisas, ignora os tokens de comentários, NL e espaços
 */

//Elemento Raiz (Regra S? - inicial)
Model returns Model:
	{Model}
	(visibility=VisibilityKind)?
	'model' name=ID
	('viewpoint' viewpoint=STRING)?
	'{'
		//('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		//('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		//
		//('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		//('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		//('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		//('packageMerge' '{' packageMerge+=PackageMerge ( "," packageMerge+=PackageMerge)* '}' )?
		(packagedElement+=PackageableElement)*
	'}'
;


//Regras de Herança para tipos que (deveriam ser) abstratos
//Talvez elas sejam inúteis, uma vez que o metamodelo Ecore não será gerado a partir dessa gramática
PackageableElement returns PackageableElement:
//	Association_Impl | GeneralizationSet
//	Class_Impl | Model | Enumeration | EnumerationLiteral | PrimitiveType
//	| StringExpression | Expression_Impl | OpaqueExpression | LiteralInteger | LiteralString | LiteralBoolean | LiteralNull | InstanceValue | LiteralUnlimitedNatural //(ACHO que não precisa, só se forem named)
	Dependency | Constraintx |
	Package_Impl | GeneralizationSet | DataType_Impl | InstanceSpecification_Impl |
	SubKind | Kind | Phase | Role | RoleMixin | Mixin | Mode | Relator | Characterization | Mediation | Derivation | FormalAssociation | MaterialAssociation
	| Category | Collective | Quantity
//	| Quantity | Collective | Category | subQuantityOf | subCollectionOf | memberOf | componentOf | Characterization
;


NonExpressionValue returns ValueSpecification:
	LiteralInteger | LiteralString | LiteralNull | LiteralBoolean | InstanceValue | OpaqueExpression
;

ValueSpecification returns ValueSpecification:
	//StringExpression | //O que é iso???
	NonExpressionValue |  ExpressionValue
;

//Inútil -> Gerado automaticamente pelo Wizard do xText
//EObject returns ecore::EObject:
//	EObject_Impl | EAttribute | EAnnotation | EClass | EDataType_Impl | EEnum | EEnumLiteral | EFactory | EOperation | EPackage | EParameter | EReference | EGenericType | ETypeParameter;


/*
Element returns Element:
	Comment | Package_Impl | Dependency | ElementImport | PackageImport | Constraintx | Association_Impl | Generalization | GeneralizationSet | OpaqueExpression | Property | Class_Impl | Model | DataType_Impl | StringExpression | Expression_Impl | PackageMerge | Enumeration | EnumerationLiteral | InstanceSpecification_Impl | Slot | PrimitiveType | LiteralInteger | LiteralString | LiteralBoolean | LiteralNull | InstanceValue | LiteralUnlimitedNatural | SubKind | Kind | Quantity | Collective | Phase | Role | Category | RoleMixin | Mixin | Mode | Relator | subQuantityOf | subCollectionOf | memberOf | componentOf | Characterization | Mediation | Derivation | FormalAssociation | MaterialAssociation;

NamedElement returns NamedElement:
	Package_Impl | Dependency | Constraintx | Association_Impl | GeneralizationSet | OpaqueExpression | Property | Class_Impl | Model | DataType_Impl | StringExpression | Expression_Impl | Enumeration | EnumerationLiteral | InstanceSpecification_Impl | PrimitiveType | LiteralInteger | LiteralString | LiteralBoolean | LiteralNull | InstanceValue | LiteralUnlimitedNatural | SubKind | Kind | Quantity | Collective | Phase | Role | Category | RoleMixin | Mixin | Mode | Relator | subQuantityOf | subCollectionOf | memberOf | componentOf | Characterization | Mediation | Derivation | FormalAssociation | MaterialAssociation;

Type returns Type:
	Association_Impl | Class_Impl | DataType_Impl | Enumeration | PrimitiveType | SubKind | Kind | Quantity | Collective | Phase | Role | Category | RoleMixin | Mixin | Mode | Relator | subQuantityOf | subCollectionOf | memberOf | componentOf | Characterization | Mediation | Derivation | FormalAssociation | MaterialAssociation;

Package returns Package:
	Package_Impl | Model;



Classifier returns Classifier:
	Association_Impl | Class_Impl | DataType_Impl | Enumeration | PrimitiveType | SubKind | Kind | Quantity | Collective | Phase | Role | Category | RoleMixin | Mixin | Mode | Relator | subQuantityOf | subCollectionOf | memberOf | componentOf | Characterization | Mediation | Derivation | FormalAssociation | MaterialAssociation;

Association returns Association:
	Association_Impl | subQuantityOf | subCollectionOf | memberOf | componentOf | Characterization | Mediation | Derivation | FormalAssociation | MaterialAssociation;

StructuralFeature returns StructuralFeature:
	Property;

InstanceSpecification returns InstanceSpecification:
	InstanceSpecification_Impl | EnumerationLiteral;

*/

DataType_Impl returns DataType:
	(visibility=VisibilityKind)?
	'datatype'
	name=ID
	('{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
    '}')?
;

//Mesma coisa que DataType
PrimitiveType returns PrimitiveType:
	(visibility=VisibilityKind)?
	'type'
	name=ID
	('{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
    '}')?
;

Dependency returns Dependency:
	{Dependency}
	(visibility=VisibilityKind)?
	'Dependency'
	(name=ID)?
	'{'
		client+=[NamedElement] (',' client+=[NamedElement])*
		'depends on' '(' supplier+=[NamedElement] ( ',' supplier+=[NamedElement])* ')'  
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
    '}'
;



ElementImport returns ElementImport:
	(visibility=VisibilityKind)?
	'import'
	importedElement=[PackageableElement|STRING]
	('as' alias=ID)?
	';'
;

PackageImport returns PackageImport:
	visibility=VisibilityKind
	'import' importedPackage=[Package|STRING]
	';'
;

Constraintx returns Constraintx:
	(visibility=VisibilityKind)?
	'constraint'
	('(' constrainedElement+=[Element] ( "," constrainedElement+=[Element])* ')' )?
	'{'
		specification=ValueSpecification
    '}'
;

PackageMerge returns PackageMerge:
	{PackageMerge}
	//('PackageMerge')?
	mergedPackage=[Package|STRING]
;

Package_Impl returns Package:
	{Package}
	(visibility=VisibilityKind)?
	'package'
	name=ID
	'{'
		('merge' ':' packageMerge+=PackageMerge ( ',' packageMerge+=PackageMerge)* )?
		(packagedElement+=PackageableElement)*
	'}'
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
;

/*****************************************************************************
 * Duvida:
 * Generalization::generalizationSet é uma collection, por que?
 *****************************************************************************/
InlineGeneralization returns Generalization:
	isSubstitutable?='substitutable'?
	general=[Classifier]
	('(' generalizationSet+=[GeneralizationSet] (',' generalizationSet+=[GeneralizationSet])* ')' )?
	//('(' generalizationSet+=[GeneralizationSet] ')' )?
;


/*
 * Problema: Não tem name, como referenciar?
 */
Generalization returns Generalization:
	//isSubstitutable?='substitutable'? //Default tá sendo TRUE?
	'generalization'
	'of' general=[Classifier]
	'as' owner=[Classifier]
	';'
;

/*****************************************************************************
 * Problemas:
 * GeneralizationSet::generalization é opposite, mas não está sendo definida automaticamente
 * Motivo: http://www.eclipse.org/forums/index.php/t/245235/
 * Solução, mudar essas opposite que são assim, para transient="true" e resolveProxies="false"
 *****************************************************************************/
GeneralizationSet returns GeneralizationSet:
	visibility=VisibilityKind?
	( isCovering?='complete'? & isDisjoint?='disjoint'? )
	'generalizationSet' name=ID
	'{'
    '}'
;


//Um operador (+, -, >, <)
ExpressionSymbol returns ecore::EString:
	ID | ANY_OTHER+
;

/*
 *
 * (100 + 100 - 200)
 * media {10, 20, 30}
 * not 100
 */
 //TODO: resolver o left-recursion
ExpressionValue returns Expression:
	{Expression}
	'('
		(
		 //Se eu tiro o parenteses dá left-recursion 
		 (operand+=ValueSpecification symbol=ExpressionSymbol operand+=ValueSpecification) |
		 (symbol=ExpressionSymbol operand+=ValueSpecification) |
		 (symbol=ExpressionSymbol '{' operand+=ValueSpecification (',' operand+=ValueSpecification)+ '}')
		)
    ')'
//	'Expression'
//		('name' name=ID)?
//		('visibility' visibility=VisibilityKind)?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('type' type=[Type|EString])?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
;

/*
private OpaqueExpression opaqExp1 (Person) : "Python", "Ruby"
		begin
			# Reinaldo de souza junior
			# Reinaldo2
		end
*/
OpaqueExpression returns OpaqueExpression:	//OK
	{OpaqueExpression}
	(visibility=VisibilityKind)?
	'OpaqueExpression'
	(name=ID)?
	('(' type=[Type] ')')?
	':' language+=STRING ( ','  language+=STRING)*
	//'begin' body+=OPAQUE_TEXT 'end'
	'begin' ('#' body+=LINE)* 'end'
;


LINE returns ecore::EString: (ID|INT|RWS|ANY_OTHER)+; 
//OPAQUE_TEXT returns ecore::EString:
//	LINE (NL LINE)*
//;




//+ -> concatena
//% -> interpola
//StringExpressionSymbol returns ecore::EString:
//	'+' | '%'
//	;

//Isso seria uma expressão Terminal?
//Se eu substituir o primeiro operand+=ValueSpecification por operand+=TerminalStringExpression funcionaria sem left-recursion
//TerminalStringExpression returns StringExpression:
//	operand+=LiteralString
//	;

//WTF is a StringExpression?
//Devo usar subExpresion, symbol, subExpression
//ou devo usar operand, symbol, operand (de Expression)
//Aqui eu definiria quais as operações poderiam ser realizadas com STRINGs? 
/*
StringExpression returns StringExpression:
	{StringExpression}
	//"Reinaldo" + " Junior"
	('(' //Se eu tirar o parenteses eu vou ter uma chamada recursiva à esquerda, o que não pode no ANTLR
		operand+=ValueSpecification
		symbol='+'
		operand+=ValueSpecification
	')')
	//("Reinaldo %1 conheçe %2? %3" % "Junior", instancia_maria.nome, true)
	| ('('
		operand+=ValueSpecification
		symbol='%'
		operand+=ValueSpecification (',' operand+=ValueSpecification )?
	')')
// //Seria como uma operação, apenas
//	|
//	('('
//		operand+=StringExpression
//		symbol=StringExpressionSymbol
//		operand+=ValueSpecification
//	')')
    ;
*/


//PropertyBound returns ecore::EIntegerObject: // datatype rule handled by a value converter
//PropertyBound returns ecore::EIntegerObject: // datatype rule handled by a value converter
//    '*' | INT;

/*****************************************************************************
 * property nome (TipoNome)
 * property amigos [2, 3] (TipoNome)
 *****************************************************************************
 * Problemas:
 * Property::association é opposite, mas não está sendo definida automaticamente
 *****************************************************************************/
//ATENTION: Ao mudar, mude também o de baixo
InlinePropertyDefinition returns Property:
	{Property}
	(visibility=VisibilityKind)?
	'property'
	(
	  '<'
	   ( isStatic?='static'? & isOrdered?='ordered'? & isUnique?='unique'? & isReadOnly?='read-only'? & isDerivedUnion?='derived-union'? )
	   '>'
	)?
	name=ID?
	//Cardinalidade tá dando problema porque o Roberto usa umas convenções malucas...
	//EM Multiplicity Element
	//upper (derived)-> upperBound (derived)-> upperValue
	//lower (derived)-> lowerBound (derived)-> lowerValue
	//Quando eu insiro tô recebendo um problema com uma restrição:
	//The 'ClassAttributeConstraint1' constraint is violated on 'RefOntoUML.impl.KindImpl@564389b7{platform:/resource/primeiro/agora.ouml#//@packagedElement.1}'
	//Class::ClassAttributeConstraint1 é:
	//ownedAttribute->forAll( x | x.lower >= 1 )
	//Com ('cardinality' '[' lowerValue=ValueSpecification ',' upperValue=ValueSpecification ']')?	//Original era esse
	//lower tá ficando vazio...
	//Mudei para
	( '[' lowerValue=LiteralInteger ',' upperValue=LiteralUnlimitedNatural ']')?

	//E alterei o valor do UnlimitedNatural=* para 0 (era -1). Com isso o erro mudou para
	//The 'LowerAndUpperBound' constraint is violated on 'RefOntoUML.impl.PropertyImpl@1412504b{platform:/resource/primeiro/agora.ouml#//@packagedElement.1/@ownedAttribute.1}'
	'(' type=[Type] ')'
	('{'
		('defaults to' defaultValue=ValueSpecification)?
		('aggregation' aggregation=AggregationKind)?
		('subset of' '(' subsettedProperty+=[Property] ( "," subsettedProperty+=[Property])* ')' )?
		('redefines' '(' redefinedProperty+=[Property] ( "," redefinedProperty+=[Property])* ')' )?
    '}')?
    ;


/*
//Igual a propriedade
//relation maisVelhoQue(Pessoa) //FormalAssociation entre Pessoa e Pessoa
//relation casadoCom(Pessoa) throught contratoDeCasamento //MaterialAssociation

Relation returns Property:
	(visibility=VisibilityKind)?
	'relation'
	('('
	 (isStatic?='static' & isOrdered?='ordered' & isUnique?='unique' & isReadOnly?='read-only' & isDerivedUnion?='derived-union')
	 ')'
	)?
	name=ID
//	('[' upperValue=ValueSpecification ',' lowerValue=ValueSpecification ']')?
	':' type=[Type]
//	('default=' defaultValue=ValueSpecification)?

//?
//	'->' association=[Association|ID]
//	owningAssociation+=[Association]
//	owningAssociation=[Association] //oposite -> ownedEnd
	association=[Association] //oposite -> memberEnd

	('{'
		('aggregation' aggregation=AggregationKind)?
		('subset of' '(' subsettedProperty+=[Property|STRING] ( "," subsettedProperty+=[Property|STRING])* ')' )?
		('redefines' '(' redefinedProperty+=[Property|STRING] ( "," redefinedProperty+=[Property|STRING])* ')' )?

//		
//Opposite em Dependency, não precisa definir
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
    '}')?
;
*/

/*

*** Associations ***

2) (Carraretto, 2010, p.70).

- memberEnd:
Todas as Classes (na verdade, Properties) que estão sendo relacionadas em uma Association ficam em 'memberEnd'.

- ownedEnd:
Algumas dessas Classes (na verdade, Properties) ficam sob posse da Association, essas Classes são referenciadas por 'ownedEnd'. Tradicionalmente, todas as Classes (na verdade, Properties) ficam sob posse da Association. Mas é possível em UML fazer a Class ser dona da Property, ao invés da Association. A sintaxe concreta é um "ponto" entre a linha da association e a classe. 99% das vezes owned possui as mesmas Properties que memberEnd.

- navigableOwnedEnd:
Algumas dessas Classes (na verdade, Properties) que a Association tem posse são navegáveis. Tradicionalmente, uma Association é navegável em todos os sentidos, até que você fale o contrário. A sintaxe concreta é uma "seta" entre a linha da Association e a Class. 70% das vezes navigableOwnedEnd possui as mesmas Properties de ownedEnd.

- endType:
Igual memberEnd, mas ao invés de retornar Properties retorna Classes. É uma relação derived.
self.memberEnd->collect(e | e.type)
*/



/*
 *
 * ownedMember vs ownedElement (derivada)
 * endType (derivada)

mediation M1 {
	Person : property <unique> p1[1,1] (Person)
	Animal : property <read-only> p2[1,1] (Animal)
}
*/
Mediation returns Mediation:
	{Mediation}
	(visibility=VisibilityKind)?
	'mediation' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
	(	
		( ownedEnd+=InlinePropertyDefinition ';' )+
		& ('memberEnd' ':' memberEnd+=[Property] (',' memberEnd+=[Property])* ';' )?
		& ('navigableOwnedEnd' ':' navigableOwnedEnd+=[Property] ( ',' navigableOwnedEnd+=[Property])* ';' )?
	)
    '}'
;

Derivation returns Derivation:
	visibility=VisibilityKind?
	( isDerived?='derived'? & isAbstract?='abstract'? & isLeaf?='leaf'? )
	'derivation' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		'material:' ( ownedEnd+=InlinePropertyDefinition ';' )
		'relator:' ( ownedEnd+=InlinePropertyDefinition ';' )
	(
		('memberEnd' ':' memberEnd+=[Property] (',' memberEnd+=[Property])* ';' )?
		& ('navigableOwnedEnd' ':' navigableOwnedEnd+=[Property] ( ',' navigableOwnedEnd+=[Property])* ';' )?
	)
    '}'
;

/*
 *
 * public property casadoCom (Pessoa) throught contratoDeCasamento //MaterialAssociation
 * OCL: Precisa de um Derivation cujo memberEnd[1] = MaterialAssociation
 */
MaterialAssociation returns MaterialAssociation:
	{MaterialAssociation}
	visibility=VisibilityKind?
	//Derived é OBRIGATORIO
	( isDerived?='derived' & isAbstract?='abstract'? & isLeaf?='leaf'? )
	'materialAssociation' name=ID?
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
	(	
		( ownedEnd+=InlinePropertyDefinition ';' )+
		& ('memberEnd' ':' memberEnd+=[Property] (',' memberEnd+=[Property])* ';' )?
		& ('navigableOwnedEnd' ':' navigableOwnedEnd+=[Property] ( ',' navigableOwnedEnd+=[Property])* ';' )?
	)
    '}'
;


//public property maisVelhoQue (Pessoa) //FormalAssociation entre Pessoa e Pessoa
FormalAssociation returns FormalAssociation:
	{FormalAssociation}
	visibility=VisibilityKind?
	( isAbstract?='abstract'? & isDerived?='derived'? & isLeaf?='leaf'? )
	'formalAssociation' name=ID?
	'{'
	(	
		( ownedEnd+=InlinePropertyDefinition ';' )+
		& ('memberEnd' ':' memberEnd+=[Property] (',' memberEnd+=[Property])* ';' )?
		& ('navigableOwnedEnd' ':' navigableOwnedEnd+=[Property] ( ',' navigableOwnedEnd+=[Property])* ';' )?
	)
    '}'
	;
	
/* 
Association_Impl returns Association:
	'Association'
	'{'
		('name' name=ID)?
		('visibility' visibility=VisibilityKind)?
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property|EString] ( "," memberEnd+=[Property|EString])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property|EString] ( "," navigableOwnedEnd+=[Property|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('ownedEnd' '{' ownedEnd+=Property ( "," ownedEnd+=Property)* '}' )?
    '}';


Class_Impl returns Class:
	'Class'
	'{'
		('name' name=ID)?
		('visibility' visibility=VisibilityKind)?

		
		'isActive' isActive=Boolean
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
    '}';

*/


Enumeration returns Enumeration:
	(visibility=VisibilityKind)?
	'enum'
	name=ID
	'{'
		ownedLiteral+=EnumerationLiteral ( "," ownedLiteral+=EnumerationLiteral)*
//		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?

//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
	'}'
;

EnumerationLiteral returns EnumerationLiteral:
	{EnumerationLiteral}
//	'EnumerationLiteral'
//	'{'
		name=ID
		'='
		specification=ValueSpecification
//		('visibility' visibility=VisibilityKind)?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('classifier' '(' classifier+=[Classifier|EString] ( "," classifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?	
//		('slot' '{' slot+=Slot ( "," slot+=Slot)* '}' )?
//    '}'
;

/*
 * Especifica uma instância
 */
InstanceSpecification_Impl returns InstanceSpecification: //OK
	{InstanceSpecification}
	(visibility=VisibilityKind)?
	'instance'
	name=ID
	(':' classifier+=[Classifier] ( "," classifier+=[Classifier])* )?
	('specification' specification=ValueSpecification)?
	'{' (slot+=Slot ( "," slot+=Slot)*)? '}'
;

Slot returns Slot: //OK
	definingFeature=[StructuralFeature|STRING]
	'=>'
	(value+=ValueSpecification | '[' value+=ValueSpecification ( "," value+=ValueSpecification)* ']' )
;

//InstanceValue
/*
 * Refere-se a uma instânca como um valor
 *
 * private instance reinaldinho (Person)
*/
InstanceValue returns InstanceValue: //OK
	(visibility=VisibilityKind)?
	'instance'
	(name=ID)?
	('(' type=[Type] ')')?
	instance=[InstanceSpecification]
;


//Um UnlimitedNatural pode ser reduzido a um INT assim como um LiteralInteger
//Por isso tá dando ambiguidade na gramática??? Mas ainda assim está funcionando.
LiteralInteger returns LiteralInteger:
	{LiteralInteger}
	value=INT
;

LiteralString returns LiteralString:
	{LiteralString}
	value=STRING
;

LiteralBoolean returns LiteralBoolean:
	{LiteralBoolean}
	value=Boolean
	;

Boolean returns ecore::EBoolean:
	'true' | 'false'
;

//Acho que não precisa
//EBoolean returns ecore::EBoolean:
//	'true' | 'false';

LiteralUnlimitedNatural:
	value=UnlimitedNaturalValue | value=INT
;

UnlimitedNaturalValue returns /*ecore::EInt*/ ecore::EIntegerObject:
	'*' // | INT
;

//Tentar um ValueConverter??
LiteralNull returns LiteralNull:
	{LiteralNull}
	'NULL'
;

/*
 * ONTOUML
 */


SubKind returns SubKind:
	(visibility=VisibilityKind)?
	isActive?='active'?
	'subkind' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* )?
    '}';

Kind returns Kind:
	(visibility=VisibilityKind)?
	'kind' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* '}' )?
//
//		
//		'isActive' isActive=Boolean
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
    '}';

Quantity returns Quantity:
	(visibility=VisibilityKind)?
	isActive?='active'?
	'quantity' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
/*
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
*/
    '}';

Collective returns Collective:
	(visibility=VisibilityKind)?
	isExtensional?='extensional'?
	'collective' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
/*
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
*/
    '}';

Phase returns Phase:
	(visibility=VisibilityKind)?
	'phase'	name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
//		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
    '}';

Role returns Role:
	(visibility=VisibilityKind)?
	'role' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* '}' )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
    '}';

//superClass
//generalization
Category returns Category:
	visibility=VisibilityKind?
	isAbstract?='abstract' //Precisa sempre ser abstract: MixinClassConstraint2. Essa constraint, não poderia ser isABstract != false? (pois assim, abstract null seria válida)
	'category' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=InlinePropertyDefinition ( "," ownedAttribute+=InlinePropertyDefinition)* '}' )?
    '}';

RoleMixin returns RoleMixin:
	(visibility=VisibilityKind)?
	'roleMixin' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* '}' )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
    '}';

Mixin returns Mixin:
	visibility=VisibilityKind?
	isAbstract?='abstract' //Precisa sempre ser abstract: MixinClassConstraint2. Essa constraint, não poderia ser isABstract != false? (pois assim, abstract null seria válida)
	'mixin' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* '}' )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
    '}';

Mode returns Mode:
	(visibility=VisibilityKind)?
	'mode' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* '}' )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
    '}';

Relator returns Relator:
	(visibility=VisibilityKind)?
	'relator' name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
		('attributes:' '{' (ownedAttribute+=InlinePropertyDefinition)* '}' )?
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
//		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
//		('nestedClassifier' '{' nestedClassifier+=Classifier ( "," nestedClassifier+=Classifier)* '}' )?
    '}';

/*

subQuantityOf returns subQuantityOf:
	'subQuantityOf' name=ID
	'{'
		('visibility' visibility=VisibilityKind)?
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property|EString] ( "," memberEnd+=[Property|EString])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property|EString] ( "," navigableOwnedEnd+=[Property|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('ownedEnd' '{' ownedEnd+=Property ( "," ownedEnd+=Property)* '}' )?
    '}';

subCollectionOf returns subCollectionOf:
	'subCollectionOf' name=ID
	'{'
		('visibility' visibility=VisibilityKind)?
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property|EString] ( "," memberEnd+=[Property|EString])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property|EString] ( "," navigableOwnedEnd+=[Property|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('ownedEnd' '{' ownedEnd+=Property ( "," ownedEnd+=Property)* '}' )?
    '}';

memberOf returns memberOf:
	'memberOf'
	'{'
		('name' name=ID)?
		('visibility' visibility=VisibilityKind)?
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property|EString] ( "," memberEnd+=[Property|EString])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property|EString] ( "," navigableOwnedEnd+=[Property|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('ownedEnd' '{' ownedEnd+=Property ( "," ownedEnd+=Property)* '}' )?
    '}';

componentOf returns componentOf:
	'componentOf'
	'{'
		('name' name=ID)?
		('visibility' visibility=VisibilityKind)?
		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property|EString] ( "," memberEnd+=[Property|EString])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property|EString] ( "," navigableOwnedEnd+=[Property|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		
		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('generalization' '{' generalization+=Generalization ( "," generalization+=Generalization)* '}' )?
		('ownedEnd' '{' ownedEnd+=Property ( "," ownedEnd+=Property)* '}' )?
    '}';

*/

Characterization returns Characterization:
	(visibility=VisibilityKind)?
	'Characterization'
	name=ID
	(':' generalization+=InlineGeneralization ( ',' generalization+=InlineGeneralization)* )?
	'{'
//		('clientDependency' '(' clientDependency+=[Dependency|EString] ( "," clientDependency+=[Dependency|EString])* ')' )?
//		('powertypeExtent' '(' powertypeExtent+=[GeneralizationSet|EString] ( "," powertypeExtent+=[GeneralizationSet|EString])* ')' )?
//		('redefinedClassifier' '(' redefinedClassifier+=[Classifier|EString] ( "," redefinedClassifier+=[Classifier|EString])* ')' )?
		'memberEnd' '(' memberEnd+=[Property] ( "," memberEnd+=[Property])* ')' 
		('navigableOwnedEnd' '(' navigableOwnedEnd+=[Property] ( "," navigableOwnedEnd+=[Property])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
//		
//		('elementImport' '{' elementImport+=ElementImport ( "," elementImport+=ElementImport)* '}' )?
//		('packageImport' '{' packageImport+=PackageImport ( "," packageImport+=PackageImport)* '}' )?
//		('ownedRule' '{' ownedRule+=Constraintx ( "," ownedRule+=Constraintx)* '}' )?
		('ownedEnd' '{' ownedEnd+=InlinePropertyDefinition ( "," ownedEnd+=InlinePropertyDefinition)* '}' )?
    '}';


//Terminals
//RWS -> Real White Space (fiz isso porque os terminais padrão do xText não diferenciam WhiteSpace de New-Line
terminal RWS: (' '|'\t')+;
terminal NL: ('\r'|'\n')+;
terminal WS: (RWS|NL)+;
//terminal WORD: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+;


//Lista de Enumerações
enum AggregationKind returns AggregationKind:
	none = 'none' | shared = 'shared' | composite = 'composite';

enum VisibilityKind returns VisibilityKind:
	public = 'public' | private = 'private' | protected = 'protected' | package = 'package';

/*
EClassifier returns ecore::EClassifier:
	EClass | EDataType_Impl | EEnum;

EStructuralFeature returns ecore::EStructuralFeature:
	EAttribute | EReference;

EAnnotation returns ecore::EAnnotation:
	{ecore::EAnnotation}
	'EAnnotation'
	'{'
		('source' source=EString)?
		('references' '(' references+=[ecore::EObject|EString] ( "," references+=[ecore::EObject|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('details' '{' details+=EStringToStringMapEntry ( "," details+=EStringToStringMapEntry)* '}' )?
		('contents' '{' contents+=EObject ( "," contents+=EObject)* '}' )?
    '}';

//SL_COMMENT | ML_COMMENT
Comment returns Comment:
	{Comment}
	'Comment'
	'{'
		('body' body=STRING)?
		('annotatedElement' '(' annotatedElement+=[Element|EString] ( "," annotatedElement+=[Element|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
    '}';
    
EString returns ecore::EString:
	STRING | ID;

EStringToStringMapEntry returns ecore::EStringToStringMapEntry:
	{ecore::EStringToStringMapEntry}
	'EStringToStringMapEntry'
	'{'
		('key' key=EString)?
		('value' value=EString)?
    '}';

EObject_Impl returns ecore::EObject:
	{ecore::EObject}
	'EObject'
;

EAttribute returns ecore::EAttribute:
	{ecore::EAttribute}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(iD?='iD')?
	'EAttribute'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('changeable' changeable=EBoolean)?
		('defaultValueLiteral' defaultValueLiteral=EString)?
		('eType' eType=[ecore::EClassifier|EString])?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
    '}';

EClass returns ecore::EClass:
	{ecore::EClass}
	(abstract?='abstract')?
	(interface?='interface')?
	'EClass'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('eSuperTypes' '(' eSuperTypes+=[ecore::EClass|EString] ( "," eSuperTypes+=[ecore::EClass|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eOperations' '{' eOperations+=EOperation ( "," eOperations+=EOperation)* '}' )?
		('eStructuralFeatures' '{' eStructuralFeatures+=EStructuralFeature ( "," eStructuralFeatures+=EStructuralFeature)* '}' )?
		('eGenericSuperTypes' '{' eGenericSuperTypes+=EGenericType ( "," eGenericSuperTypes+=EGenericType)* '}' )?
    '}';


EDataType_Impl returns ecore::EDataType:
	{ecore::EDataType}
	'EDataType'
	name=ID
	'{'
//		('instanceClassName' instanceClassName=EString)?
//		('instanceTypeName' instanceTypeName=EString)?
//		('serializable' serializable=EBoolean)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
//		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
    '}';


EEnum returns ecore::EEnum:
	{ecore::EEnum}
	'EEnum'
	name=EString
	'{'
		('instanceClassName' instanceClassName=EString)?
		('instanceTypeName' instanceTypeName=EString)?
		('serializable' serializable=EBoolean)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eLiterals' '{' eLiterals+=EEnumLiteral ( "," eLiterals+=EEnumLiteral)* '}' )?
    '}';

EEnumLiteral returns ecore::EEnumLiteral:
	{ecore::EEnumLiteral}
	'EEnumLiteral'
	name=EString
	'{'
		('value' value=EInt)?
		('literal' literal=EString)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
    '}';

EFactory returns ecore::EFactory:
	{ecore::EFactory}
	'EFactory'
	'{'
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
    '}';

EOperation returns ecore::EOperation:
	{ecore::EOperation}
	'EOperation'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eExceptions' '(' eExceptions+=[ecore::EClassifier|EString] ( "," eExceptions+=[ecore::EClassifier|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
		('eTypeParameters' '{' eTypeParameters+=ETypeParameter ( "," eTypeParameters+=ETypeParameter)* '}' )?
		('eParameters' '{' eParameters+=EParameter ( "," eParameters+=EParameter)* '}' )?
		('eGenericExceptions' '{' eGenericExceptions+=EGenericType ( "," eGenericExceptions+=EGenericType)* '}' )?
    '}';

EPackage returns ecore::EPackage:
	{ecore::EPackage}
	'EPackage'
	name=EString
	'{'
		('nsURI' nsURI=EString)?
		('nsPrefix' nsPrefix=EString)?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eClassifiers' '{' eClassifiers+=EClassifier ( "," eClassifiers+=EClassifier)* '}' )?
		('eSubpackages' '{' eSubpackages+=EPackage ( "," eSubpackages+=EPackage)* '}' )?
    '}';

EParameter returns ecore::EParameter:
	{ecore::EParameter}
	'EParameter'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('eType' eType=[ecore::EClassifier|EString])?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
    '}';

EReference returns ecore::EReference:
	{ecore::EReference}
	(volatile?='volatile')?
	(transient?='transient')?
	(unsettable?='unsettable')?
	(derived?='derived')?
	(containment?='containment')?
	'EReference'
	name=EString
	'{'
		('ordered' ordered=EBoolean)?
		('unique' unique=EBoolean)?
		('lowerBound' lowerBound=EInt)?
		('upperBound' upperBound=EInt)?
		('changeable' changeable=EBoolean)?
		('defaultValueLiteral' defaultValueLiteral=EString)?
		('resolveProxies' resolveProxies=EBoolean)?
		('eType' eType=[ecore::EClassifier|EString])?
		('eOpposite' eOpposite=[ecore::EReference|EString])?
		('eKeys' '(' eKeys+=[ecore::EAttribute|EString] ( "," eKeys+=[ecore::EAttribute|EString])* ')' )?
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eGenericType' eGenericType=EGenericType)?
    '}';

EGenericType returns ecore::EGenericType:
	{ecore::EGenericType}
	'EGenericType'
	'{'
		('eTypeParameter' eTypeParameter=[ecore::ETypeParameter|EString])?
		('eClassifier' eClassifier=[ecore::EClassifier|EString])?
		('eUpperBound' eUpperBound=EGenericType)?
		('eTypeArguments' '{' eTypeArguments+=EGenericType ( "," eTypeArguments+=EGenericType)* '}' )?
		('eLowerBound' eLowerBound=EGenericType)?
    '}';

ETypeParameter returns ecore::ETypeParameter:
	{ecore::ETypeParameter}
	'ETypeParameter'
	name=EString
	'{'
		//('eAnnotations' '{' eAnnotations+=EAnnotation ( "," eAnnotations+=EAnnotation)* '}' )?
		('eBounds' '{' eBounds+=EGenericType ( "," eBounds+=EGenericType)* '}' )?
    '}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

EInt returns ecore::EInt:
	'-'? INT;
*/